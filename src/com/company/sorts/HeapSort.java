package com.company.sorts;

public class HeapSort extends Sort{
    @Override
    public void doSort(int[] array){
        time = 0;
        long start = System.currentTimeMillis();
        moves = 0;
        evaluates = 0;
        sort(array);
        time = System.currentTimeMillis() - start;
    }
    public void sort(int arr[]) {
        int N = arr.length;

        //Создаём из массива сортирующее дерево
        //Максимальный элемент окажется в корне.
        for (int k = N / 2; k > 0; k--) downHeap(arr, k, N);

        //Избавляемся от максимумов
        //и перетряхиваем сортирующее дерево
        do {
            moves +=3;
            //Меняем максимум с последним элементом...
            int T = arr[0];
            arr[0] = arr[N - 1];
            arr[N - 1] = T;

            //... и перестравиваем сортирующее дерево
            //для неотсортированной части массива
            N = N - 1;
            downHeap(arr, 1, N);

        } while (N > 1); //До последнего элемента
    }

    //Просматриваем ветку и в её корень перемещаем наибольший узел
    private void downHeap(int a[], int k, int N) {

        //В корне поддерева
        //запоминаем родителя
        int T = a[k - 1];
        moves++;
        //Смотрим потомков в пределах ветки
        while (k <= N / 2) {
            moves++;
            int j = k + k;//Левый потомок

            //Если есть правый потомок,
            //то сравниваем его с левым
            //и из них выбираем наибольший
            if ((j < N) && (a[j - 1] < a[j])) j++;

            //Если родитель больше (или равен) наибольшего потомка...
            if (T >= a[j - 1]) {

                //... то значит всё в порядке в этой ветке
                break;

            } else { //Если родитель меньше наибольшего потомка...
                moves += 2;
                //... то потомок становится на место родителя
                a[k - 1] = a[j - 1];
                k = j;

            }
        }

        //Родитель в итоге меняется местами с наибольшим из потомков
        //(или остаётся на своём месте, если все потомки меньше его)
        a[k - 1] = T;
        moves++;
    }
}
